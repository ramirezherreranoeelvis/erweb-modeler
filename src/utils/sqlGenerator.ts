import type { Table, Relationship, Column } from '../ui/types';
import type { DbEngine } from './dbDataTypes';
import { generateId } from './geometry';

export const generateSQL = (
  tables: Table[],
  relationships: Relationship[],
  engine: DbEngine
): string => {
  const isMysql = engine === 'mysql';
  const q = isMysql ? '`' : '[';
  const qe = isMysql ? '`' : ']';
  const identity = isMysql ? 'AUTO_INCREMENT' : 'IDENTITY(1,1)';

  // 1. Prepare Physical Schema (Resolve N:M)
  const physTables: Table[] = JSON.parse(JSON.stringify(tables)); // Deep copy
  const physRels: Relationship[] = [];

  relationships.forEach((rel) => {
    if (rel.type === 'N:M') {
      const sourceTable = tables.find((t) => t.id === rel.fromTable);
      const targetTable = tables.find((t) => t.id === rel.toTable);

      if (sourceTable && targetTable) {
        const intersectName = rel.name
          ? rel.name.toUpperCase()
          : `${sourceTable.name}_${targetTable.name}`;
        
        // Generate a deterministic ID for export purposes if possible, but random is fine for script generation
        const intersectId = `virt_${rel.id}`;
        
        const newColumns: Column[] = [];
        
        // Helper to get custom name or default
        const getColName = (baseId: string, defaultName: string) => {
          if (rel.virtualColNames && rel.virtualColNames[baseId]) {
            return rel.virtualColNames[baseId];
          }
          return defaultName;
        };

        const sourcePks = sourceTable.columns.filter((c) => c.isPk);
        const targetPks = targetTable.columns.filter((c) => c.isPk);

        sourcePks.forEach((pk) => {
            const virtColId = `${intersectId}_src_${pk.id}`;
            newColumns.push({
                ...pk,
                id: virtColId,
                name: getColName(virtColId, pk.name), // Usually keeps PK name
                isPk: true,
                isFk: true,
                isIdentity: false, // Intersection keys are not identities usually
                isNullable: false,
                isUnique: false
            });
        });

        targetPks.forEach((pk) => {
            const virtColId = `${intersectId}_tgt_${pk.id}`;
            // Avoid name collision if both tables have "id"
            let defaultName = pk.name;
            if (newColumns.some(c => c.name.toLowerCase() === defaultName.toLowerCase())) {
                defaultName = `${targetTable.name}_${pk.name}`;
            }
            
            newColumns.push({
                ...pk,
                id: virtColId,
                name: getColName(virtColId, defaultName),
                isPk: true,
                isFk: true,
                isIdentity: false,
                isNullable: false,
                isUnique: false
            });
        });

        physTables.push({
            id: intersectId,
            name: intersectName,
            logicalName: intersectName,
            x: 0, y: 0,
            columns: newColumns
        });

        // Create relationships to the new table
        sourcePks.forEach((pk) => {
            const col = newColumns.find(c => c.id === `${intersectId}_src_${pk.id}`);
            if (col) {
                physRels.push({
                    id: generateId(),
                    name: `FK_${intersectName}_${sourceTable.name}`,
                    fromTable: sourceTable.id,
                    fromCol: pk.id,
                    toTable: intersectId,
                    toCol: col.id,
                    type: '1:N'
                });
            }
        });

        targetPks.forEach((pk) => {
            const col = newColumns.find(c => c.id === `${intersectId}_tgt_${pk.id}`);
            if (col) {
                physRels.push({
                    id: generateId(),
                    name: `FK_${intersectName}_${targetTable.name}`,
                    fromTable: targetTable.id,
                    fromCol: pk.id,
                    toTable: intersectId,
                    toCol: col.id,
                    type: '1:N'
                });
            }
        });
      }
    } else {
      physRels.push(rel);
    }
  });

  // 2. Generate SQL
  let sql = `-- Generated by ERWeb Modeler\n`;
  sql += `-- Engine: ${engine === 'mysql' ? 'MySQL' : 'SQL Server'}\n`;
  sql += `-- Date: ${new Date().toLocaleString()}\n\n`;

  // Process tables
  physTables.forEach((table) => {
    sql += `CREATE TABLE ${q}${table.name}${qe} (\n`;

    const pkCols: string[] = [];
    const lines: string[] = [];

    table.columns.forEach((col) => {
      let line = `  ${q}${col.name}${qe}`;
      
      // Type Logic
      let type = col.type;
      
      // Basic cleanup: remove empty parens ()
      if (type.endsWith('()')) type = type.slice(0, -2);
      
      // Check if we need to append length
      // If the type already has parens (e.g. DECIMAL(10,2)), we assume it's fully specified.
      // If not, and there is a length value, we append it.
      // Exceptions: MSSQL varchar(MAX) might come in as type="varchar(MAX)" or type="varchar" len="MAX" depending on how user entered it. 
      // Based on dbDataTypes.ts, "varchar(MAX)" is a type option.
      
      if (col.length && !type.includes('(')) {
        line += ` ${type}(${col.length})`;
      } else {
        line += ` ${type}`;
      }

      // Constraints
      if (!col.isNullable) line += ` NOT NULL`;
      if (col.isUnique) line += ` UNIQUE`;
      
      // Identity
      if (col.isIdentity) {
        line += ` ${identity}`;
      }

      lines.push(line);

      if (col.isPk) pkCols.push(col.name);
    });

    // Primary Keys
    if (pkCols.length > 0) {
      if (isMysql) {
        lines.push(`  PRIMARY KEY (${pkCols.map(c => `${q}${c}${qe}`).join(', ')})`);
      } else {
         lines.push(`  CONSTRAINT ${q}PK_${table.name}${qe} PRIMARY KEY (${pkCols.map(c => `${q}${c}${qe}`).join(', ')})`);
      }
    }

    sql += lines.join(',\n');
    sql += `\n);\n`;
    sql += isMysql ? '\n' : 'GO\n\n';
  });

  // Process Foreign Keys
  physRels.forEach((rel) => {
    const sourceTable = physTables.find(t => t.id === rel.fromTable);
    const targetTable = physTables.find(t => t.id === rel.toTable);
    
    if (sourceTable && targetTable) {
        const sourceCol = sourceTable.columns.find(c => c.id === rel.fromCol);
        const targetCol = targetTable.columns.find(c => c.id === rel.toCol);

        if (sourceCol && targetCol) {
            const fkName = rel.name || `FK_${targetTable.name}_${sourceTable.name}_${Math.floor(Math.random()*1000)}`;
            
            sql += `ALTER TABLE ${q}${targetTable.name}${qe}\n`;
            sql += `ADD CONSTRAINT ${q}${fkName}${qe} FOREIGN KEY (${q}${targetCol.name}${qe})\n`;
            sql += `REFERENCES ${q}${sourceTable.name}${qe} (${q}${sourceCol.name}${qe});\n`;
            sql += isMysql ? '\n' : 'GO\n\n';
        }
    }
  });

  return sql;
};